#!/usr/bin/env python3
import rclpy
from rclpy.node import Node
import Jetson.GPIO as GPIO
import time
from std_msgs.msg import Float64, Int32
import math
from geometry_msgs.msg import Twist

GPIO.setwarnings(False)

class MotorOdometer(Node):
    def __init__(self, left_encoder_pin, right_encoder_pin, gear_ratio, pulses_per_revolution, publishing_rate):
        """
        Initialize the MotorOdometer class.

        Parameters:
            left_encoder_pin (int): GPIO pin number for the left motor encoder.
            right_encoder_pin (int): GPIO pin number for the right motor encoder.
            gear_ratio (float): Gear ratio of the motor system.
            pulses_per_revolution (float): Number of pulses generated by the encoder for one revolution.
            publishing_rate (float): Publishing rate per second for RPM values and pulse counts.

        """  
        super().__init__('crobot_odom')
        self.left_encoder_pin = left_encoder_pin
        self.right_encoder_pin = right_encoder_pin
        self.gear_ratio = gear_ratio
        self.pulses_per_revolution = pulses_per_revolution
        self.publishing_interval = 1.0 / publishing_rate
        self.pulse_count_left_motor = 0
        self.pulse_count_right_motor = 0
        self.v=Twist()

        try:
            # GPIO Setup
            GPIO.setmode(GPIO.BOARD)
            GPIO.setup(left_encoder_pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
            GPIO.add_event_detect(left_encoder_pin, GPIO.FALLING, callback=self.encoder_callback_left)
            

            GPIO.setup(right_encoder_pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
            GPIO.add_event_detect(right_encoder_pin, GPIO.FALLING, callback=self.encoder_callback_right)
            self.create_subscription(Twist,'/cmd_vel',self.vel_call,1)
            # ROS2 Publishers Initialization
            self.pub_right_rpm = self.create_publisher(Float64, 'right_motor_rpm', 10)
            self.pub_left_rpm = self.create_publisher(Float64, 'left_motor_rpm', 10)
            self.pub_pulse_data_right = self.create_publisher(Int32, 'right_motor_pulses', 10)
            self.pub_pulse_data_left = self.create_publisher(Int32, 'left_motor_pulses', 10)
            

            self.timer = self.create_timer(self.publishing_interval, self.publish_data)
        except Exception as e:
            self.get_logger().error("Error initializing MotorOdometer. Ensure GPIO setup and ROS2 node initialization are correct.")
            raise Exception(e)
    def vel_call(self,msg):
        
        	
        self.v=msg
    def encoder_callback_right(self, channel):
        """
        Callback function for the right motor encoder.
        Increments the pulse count for the right motor.

        Parameters:
            channel (int): The GPIO channel that triggered the callback.
        """
        self.pulse_count_right_motor += 1
        self.get_logger().info(f"Right Encoder Triggered: {self.pulse_count_right_motor}")

    def encoder_callback_left(self, channel):
        """
        Callback function for the left motor encoder.
        Increments the pulse count for the left motor.

        Parameters:
            channel (int): The GPIO channel that triggered the callback.
        """
        self.pulse_count_left_motor += 1

    def calculate_rpm(self, pulse_count):
        """
        Calculate the RPM value based on the pulse count.

        Parameters:
            pulse_count (int): The number of pulses counted in a time interval.

        Returns:
            float: The RPM value calculated from the pulse count and gear ratio.
        """
        rpm = ((pulse_count / self.pulses_per_revolution) / self.publishing_interval * 60)*(math.pi)/ self.gear_ratio
        return self.reduce_noise(rpm)

    def reduce_noise(self, rpm):
        """
        Apply noise reduction to the RPM value.

        Parameters:
            rpm (float): RPM value to be noise-reduced.

        Returns:
            float: Noise-reduced RPM value.
        """
        # Add noise reduction logic here (e.g., averaging over previous RPM values)
        a=[]
        a.append(rpm)
        if len(a)>10:
            a.pop(0)
        rpm=sum(a)/len(a)
    
        return rpm

    def publish_data(self):
        """
        Publish the RPM values and pulse counts to ROS2 topics at the specified publishing rate.
        """
        rpm_right = abs(self.calculate_rpm(self.pulse_count_left_motor))
        rpm_left = abs(self.calculate_rpm(self.pulse_count_right_motor))
        if self.v.angular and self.v.linear.x:
            if self.v.linear.x<0.1:
                rpm_left=-rpm_left
                rpm_right=-rpm_right


        else:
                    
            if self.v.angular.z>0.1:
                rpm_left=-rpm_left

            elif self.v.angular.z<-0.1:
                rpm_right=-rpm_right

                
            if self.v.linear.x<-0.1:
                rpm_left=-rpm_left
                rpm_right=-rpm_right
        

        if self.v.linear.x or self.v.angular.z:
        	self.pub_right_rpm.publish(Float64(data=rpm_right))
        	self.pub_left_rpm.publish(Float64(data=rpm_left))
        
        	self.pub_pulse_data_right.publish(Int32(data=self.pulse_count_right_motor))
        	self.pub_pulse_data_left.publish(Int32(data=self.pulse_count_left_motor))
        else:
        	pass

        self.pulse_count_right_motor = 0
        self.pulse_count_left_motor = 0

def main(args=None):
    rclpy.init(args=args)

    # Define GPIO pin numbers, gear ratio, pulses per revolution, and publishing rate
    LEFT_MOTOR_ENCODER_PIN = 23
    RIGHT_MOTOR_ENCODER_PIN = 29
    GEAR_RATIO = 15.0
    PULSE_PER_REVOLUTION = 30.0
    PUBLISHING_RATE = 10  # Publish 10 data per second
    motor_odometer=None
    try:
        # Create an instance of the MotorOdometer class and start publishing data
        motor_odometer = MotorOdometer(LEFT_MOTOR_ENCODER_PIN, RIGHT_MOTOR_ENCODER_PIN, GEAR_RATIO, PULSE_PER_REVOLUTION, PUBLISHING_RATE)
        rclpy.spin(motor_odometer)
    except Exception as e:
        motor_odometer.get_logger().error("Error initializing or running MotorOdometer:", str(e))
    finally:
        motor_odometer.destroy_node()
        GPIO.cleanup()
        rclpy.shutdown()

if __name__ == "__main__":
    main()
